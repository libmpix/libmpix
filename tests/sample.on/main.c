/*
 * Copyright (c) 2025 tinyVision.ai Inc.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <stdint.h>
#include <assert.h>

#include <mpix/image.h>
#include <mpix/utils.h>

#define WIDTH  5
#define HEIGHT 16

static const uint8_t buf[WIDTH * HEIGHT * 3] = {
	0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x20, 0x20, 0x20, 0x30, 0x30, 0x30, 0x40, 0x40, 0x40, //
	0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x20, 0x20, 0x20, 0x30, 0x30, 0x30, 0x40, 0x40, 0x40, //
	0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x20, 0x20, 0x20, 0x30, 0x30, 0x30, 0x40, 0x40, 0x40, //
	0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x20, 0x20, 0x20, 0x30, 0x30, 0x30, 0x40, 0x40, 0x40, //
	0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x20, 0x20, 0x20, 0x30, 0x30, 0x30, 0x40, 0x40, 0x40, //
	0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x20, 0x20, 0x20, 0x30, 0x30, 0x30, 0x40, 0x40, 0x40, //
	0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x20, 0x20, 0x20, 0x30, 0x30, 0x30, 0x40, 0x40, 0x40, //
	0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x20, 0x20, 0x20, 0x30, 0x30, 0x30, 0x40, 0x40, 0x40, //
	0x0f, 0x0f, 0x0f, 0x1f, 0x1f, 0x1f, 0x2f, 0x2f, 0x2f, 0x3f, 0x3f, 0x3f, 0x4f, 0x4f, 0x4f, //
	0x0f, 0x0f, 0x0f, 0x1f, 0x1f, 0x1f, 0x2f, 0x2f, 0x2f, 0x3f, 0x3f, 0x3f, 0x4f, 0x4f, 0x4f, //
	0x0f, 0x0f, 0x0f, 0x1f, 0x1f, 0x1f, 0x2f, 0x2f, 0x2f, 0x3f, 0x3f, 0x3f, 0x4f, 0x4f, 0x4f, //
	0x0f, 0x0f, 0x0f, 0x1f, 0x1f, 0x1f, 0x2f, 0x2f, 0x2f, 0x3f, 0x3f, 0x3f, 0x4f, 0x4f, 0x4f, //
	0x0f, 0x0f, 0x0f, 0x1f, 0x1f, 0x1f, 0x2f, 0x2f, 0x2f, 0x3f, 0x3f, 0x3f, 0x4f, 0x4f, 0x4f, //
	0x0f, 0x0f, 0x0f, 0x1f, 0x1f, 0x1f, 0x2f, 0x2f, 0x2f, 0x3f, 0x3f, 0x3f, 0x4f, 0x4f, 0x4f, //
	0x0f, 0x0f, 0x0f, 0x1f, 0x1f, 0x1f, 0x2f, 0x2f, 0x2f, 0x3f, 0x3f, 0x3f, 0x4f, 0x4f, 0x4f, //
	0x0f, 0x0f, 0x0f, 0x1f, 0x1f, 0x1f, 0x2f, 0x2f, 0x2f, 0x3f, 0x3f, 0x3f, 0x4f, 0x4f, 0x4f, //
};

int main(void)
{
	struct mpix_image img = {
		.buffer = buf,
		.size = sizeof(buf),
		.fmt = { .width = WIDTH, .height = HEIGHT, .fourcc = MPIX_FMT_RGB24 }
	};
	uint16_t col_tally[5];
	uint16_t row_tally[2];

	for (int i = 0; i < 1000000; i++) {
		enum { R, G, B };
		uint8_t pix[3] = {};

		mpix_image_sample_random_rgb(&img, pix);

		assert(pix[R] == pix[G]);
		assert(pix[G] == pix[B]);
		assert(pix[R] >> 4 <= 0x4);
		assert((pix[R] & 0x0f) == 0x0 || (pix[R] & 0x0f) == 0xf);

		row_tally[pix[R] & 0x1]++;
		col_tally[pix[R] >> 4]++;
	}

	assert(row_tally[0] > 0);
	assert(row_tally[1] > 0);

	assert(col_tally[0] > 0);
	assert(col_tally[1] > 0);
	assert(col_tally[2] > 0);
	assert(col_tally[3] > 0);

	mpix_image_free(&img);

	return 0;
}

/* SPDX-License-Identifier: Apache-2.0 */

#include <stdint.h>
#include <errno.h>

#include <mpix/genlist.h>
#include <mpix/image.h>
#include <mpix/op_correction.h>
#include <mpix/utils.h>
#include <mpix/genlist.h>

void mpix_correction_op(struct mpix_base_op *base)
{
	const uint16_t line_offset = base->line_offset;
	struct mpix_correction_op *op = (void *)base;

	op->correction_fn(mpix_op_get_input_line(base), mpix_op_get_output_line(base),
			  base->width, line_offset, &op->correction);
	mpix_op_done(base);
}
__attribute__((weak))
void mpix_correction_black_level_raw8(const uint8_t *src, uint8_t *dst, uint16_t width,
				      uint16_t line_offset, union mpix_correction_any *corr)
{
	int level = corr->black_level.level;

	for (size_t w = 0; w < width; w++, src++, dst++) {
		*dst = MAX(0, *src - level);
	}
}
MPIX_REGISTER_CORRECTION_OP(blc_bggr8, mpix_correction_black_level_raw8, BLACK_LEVEL, BGGR8);
MPIX_REGISTER_CORRECTION_OP(blc_sbggr8, mpix_correction_black_level_raw8, BLACK_LEVEL, SBGGR8);
MPIX_REGISTER_CORRECTION_OP(blc_srggb8, mpix_correction_black_level_raw8, BLACK_LEVEL, SRGGB8);
MPIX_REGISTER_CORRECTION_OP(blc_sgrbg8, mpix_correction_black_level_raw8, BLACK_LEVEL, SGRBG8);
MPIX_REGISTER_CORRECTION_OP(blc_sgbrg8, mpix_correction_black_level_raw8, BLACK_LEVEL, SGBRG8);
MPIX_REGISTER_CORRECTION_OP(blc_grey, mpix_correction_black_level_raw8, BLACK_LEVEL, GREY);

__attribute__((weak))
void mpix_correction_black_level_rgb24(const uint8_t *src, uint8_t *dst, uint16_t width,
				       uint16_t line_offset, union mpix_correction_any *corr)
{
	uint8_t level = corr->black_level.level;

	for (size_t w = 0; w < width; w++, src += 3, dst += 3) {
		dst[0] = MAX(0, src[0] - level);
		dst[1] = MAX(0, src[1] - level);
		dst[2] = MAX(0, src[2] - level);
	}
}
MPIX_REGISTER_CORRECTION_OP(blc_rgb24, mpix_correction_black_level_rgb24, BLACK_LEVEL, RGB24);

__attribute__((weak))
void mpix_correction_white_balance_rgb24(const uint8_t *src, uint8_t *dst, uint16_t width,
					 uint16_t line_offset, union mpix_correction_any *corr)
{
	uint32_t red_level = corr->white_balance.red_level;
	uint32_t blue_level = corr->white_balance.blue_level;

	for (size_t w = 0; w < width; w++, src += 3, dst += 3) {
		dst[0] = MIN(src[0] * red_level >> MPIX_CORRECTION_SCALE_BITS, 0xff);
		dst[1] = src[1];
		dst[2] = MIN(src[2] * blue_level >> MPIX_CORRECTION_SCALE_BITS, 0xff);
	}
}
MPIX_REGISTER_CORRECTION_OP(wb_rgb24, mpix_correction_white_balance_rgb24, WHITE_BALANCE, RGB24);

static inline uint8_t mpix_gamma_raw8(uint8_t raw8, const uint8_t *gamma_y, const uint8_t *gamma_x,
				      size_t gamma_sz)
{
	uint8_t x0 = 0;
	uint8_t x1 = 0;
	uint8_t y0;
	uint8_t y1;

	if (raw8 == 0) {
		return 0;
	}

	/* Lookup the values through the scale of values. This is expected to be optimized
	 * into  afixed set of values by the compiler as the gamma scale is very small.
	 */
	for (size_t i = 0;; i++) {
		if (i >= gamma_sz) {
			y0 = gamma_y[i - 1];
			x1 = y1 = 0xff;
			break;
		}

		x1 = gamma_x[i];

		if (raw8 < x1) {
			y0 = gamma_y[i - 1];
			y1 = gamma_y[i - 0];
			break;
		}

		x0 = x1;
	}

	return ((x1 - raw8) * y0 + (raw8 - x0) * y1) / (x1 - x0);
}

#define MPIX_GAMMA_STEP 4
#define MPIX_GAMMA_MIN 1
#define MPIX_GAMMA_MAX 16

/* Generated by gengamma.py */
static const uint8_t mpix_gamma_y[] = {
	181, 197, 215, 234,			/* y for gamma = 1 / 16 */
	128, 152, 181, 215,			/* y for gamma = 2 / 16 */
	90, 117, 152, 197,			/* y for gamma = 3 / 16 */
	64, 90, 128, 181,			/* y for gamma = 4 / 16 */
	45, 69, 107, 165,			/* y for gamma = 5 / 16 */
	32, 53, 90, 152,			/* y for gamma = 6 / 16 */
	22, 41, 76, 139,			/* y for gamma = 7 / 16 */
	16, 32, 64, 128,			/* y for gamma = 8 / 16 */
	11, 24, 53, 117,			/* y for gamma = 9 / 16 */
	8, 19, 45, 107,				/* y for gamma = 10 / 16 */
	5, 14, 38, 98,				/* y for gamma = 11 / 16 */
	4, 11, 32, 90,				/* y for gamma = 12 / 16 */
	2, 8, 26, 82,				/* y for gamma = 13 / 16 */
	2, 6, 22, 76,				/* y for gamma = 14 / 16 */
	1, 5, 19, 69,				/* y for gamma = 15 / 16 */
};
static const uint8_t mpix_gamma_x[] = {
	1, 4, 16, 64,				/* x scale */
};

__attribute__((weak))
void mpix_correction_gamma_raw8(const uint8_t *src, uint8_t *dst, uint16_t width,
				uint16_t line_offset, union mpix_correction_any *corr)
{
	const uint8_t level = corr->gamma.level >> 5;
	const uint8_t *gamma_y = &mpix_gamma_y[(level - MPIX_GAMMA_MIN) * MPIX_GAMMA_STEP];

	for (size_t w = 0; w < width; w++, dst++, src++) {
		*dst = mpix_gamma_raw8(*src, gamma_y, mpix_gamma_x, sizeof(mpix_gamma_x));
	}
}
MPIX_REGISTER_CORRECTION_OP(gc_bggr8, mpix_correction_gamma_raw8, GAMMA, BGGR8);
MPIX_REGISTER_CORRECTION_OP(gc_sbggr8, mpix_correction_gamma_raw8, GAMMA, SBGGR8);
MPIX_REGISTER_CORRECTION_OP(gc_srggb8, mpix_correction_gamma_raw8, GAMMA, SRGGB8);
MPIX_REGISTER_CORRECTION_OP(gc_sgrbg8, mpix_correction_gamma_raw8, GAMMA, SGRBG8);
MPIX_REGISTER_CORRECTION_OP(gc_sgbrg8, mpix_correction_gamma_raw8, GAMMA, SGBRG8);
MPIX_REGISTER_CORRECTION_OP(gc_grey, mpix_correction_gamma_raw8, GAMMA, GREY);


__attribute__((weak))
void mpix_correction_gamma_rgb24(const uint8_t *src, uint8_t *dst, uint16_t width,
				 uint16_t line_offset, union mpix_correction_any *corr)
{
	const uint8_t level = corr->gamma.level >> 5;
	const uint8_t *gamma_y = &mpix_gamma_y[(level - MPIX_GAMMA_MIN) * MPIX_GAMMA_STEP];

	for (size_t w = 0; w < width; w++, dst += 3, src += 3) {
		dst[0] = mpix_gamma_raw8(src[0], gamma_y, mpix_gamma_x, sizeof(mpix_gamma_x));
		dst[1] = mpix_gamma_raw8(src[1], gamma_y, mpix_gamma_x, sizeof(mpix_gamma_x));
		dst[2] = mpix_gamma_raw8(src[2], gamma_y, mpix_gamma_x, sizeof(mpix_gamma_x));
	}
}
MPIX_REGISTER_CORRECTION_OP(gc_rgb24, mpix_correction_gamma_rgb24, GAMMA, RGB24);

__attribute__((weak))
void mpix_correction_color_matrix_rgb24(const uint8_t *src, uint8_t *dst, uint16_t width,
		                        uint16_t line_offset, union mpix_correction_any *corr)
{
	int16_t *levels = corr->color_matrix.levels;

	for (size_t w = 0; w + 3 <= width; w++, dst += 3, src += 3) {
		int32_t r;
		int32_t g;
		int32_t b;

		r = src[0] * levels[0] >> MPIX_CORRECTION_SCALE_BITS;
		g = src[1] * levels[1] >> MPIX_CORRECTION_SCALE_BITS;
		b = src[2] * levels[2] >> MPIX_CORRECTION_SCALE_BITS;
		dst[0] = CLAMP(r + g + b, 0x00, 0xff);

		r = src[0] * levels[3] >> MPIX_CORRECTION_SCALE_BITS;
		g = src[1] * levels[4] >> MPIX_CORRECTION_SCALE_BITS;
		b = src[2] * levels[5] >> MPIX_CORRECTION_SCALE_BITS;
		dst[1] = CLAMP(r + g + b, 0x00, 0xff);

		r = src[0] * levels[6] >> MPIX_CORRECTION_SCALE_BITS;
		g = src[1] * levels[7] >> MPIX_CORRECTION_SCALE_BITS;
		b = src[2] * levels[8] >> MPIX_CORRECTION_SCALE_BITS;
		dst[2] = CLAMP(r + g + b, 0x00, 0xff);
	}
}
MPIX_REGISTER_CORRECTION_OP(ccm_rgb24, mpix_correction_color_matrix_rgb24, COLOR_MATRIX, RGB24);

static const struct mpix_correction_op **mpix_correction_op_list =
	(const struct mpix_correction_op *[]){MPIX_LIST_CORRECTION_OP};

int mpix_image_correction(struct mpix_image *img, uint32_t type, union mpix_correction_any *corr)
{
	const struct mpix_correction_op *op = NULL;
	struct mpix_correction_op *new;
	int ret;

	for (size_t i = 0; mpix_correction_op_list[i] != NULL; i++) {
		const struct mpix_correction_op *tmp = mpix_correction_op_list[i];

		if (tmp->base.fourcc_src == img->fourcc &&
		    tmp->type == type) {
			op = tmp;
			break;
		}
	}

	if (op == NULL) {
		MPIX_ERR("ISP operation %u on %s data not found",
			 type, MPIX_FOURCC_TO_STR(img->fourcc));
		return mpix_image_error(img, -ENOSYS);
	}

	ret = mpix_image_append_uncompressed_op(img, &op->base, sizeof(*op));
	if (ret != 0) {
		return ret;
	}

	new = (struct mpix_correction_op *)img->ops.last;
	new->correction = *corr;

	return 0;
}

/* SPDX-License-Identifier: Apache-2.0 */

#include <mpix/low_level.h>
#include <mpix/operation.h>

MPIX_REGISTER_OP(correct_gamma);

struct mpix_operation {
	/** Fields common to all operations. */
	struct mpix_base_op base;
	/** Parameters to control the operation */
	int32_t gamma_level_q10;
};

int mpix_add_correct_gamma(struct mpix_image *img, const int32_t *params)
{
	struct mpix_operation *op;
	size_t pitch = mpix_format_pitch(&img->fmt);

	(void)params;

	/* Add an operation */
	op = mpix_op_append(img, MPIX_OP_CORRECT_GAMMA, sizeof(*op), pitch);
	if (op == NULL) return -ENOMEM;

	/* Register controls */
	img->ctrls[MPIX_CID_GAMMA_LEVEL] = &op->gamma_level_q10;

	return 0;
}

#define MPIX_GAMMA_STEPS 4
#define MPIX_GAMMA_MIN (1u << MPIX_GAMMA_BITS)
#define MPIX_GAMMA_MAX (15u << MPIX_GAMMA_BITS)

static inline uint8_t mpix_gamma_raw8(uint8_t raw8, const uint8_t *gamma_y, const uint8_t *gamma_x,
				      size_t gamma_sz)
{
	uint8_t x0 = 0;
	uint8_t x1 = 0;
	uint8_t y0;
	uint8_t y1;

	if (raw8 == 0) {
		return 0;
	}

	/* Lookup the values through the scale of values. This is expected to be optimized
	 * into a fixed set of values by the compiler as the gamma scale is very small.
	 */
	for (size_t i = 0;; i++) {
		if (i >= gamma_sz) {
			y0 = gamma_y[i - 1];
			x1 = y1 = 0xff;
			break;
		}

		x1 = gamma_x[i];

		if (raw8 < x1) {
			y0 = gamma_y[i - 1];
			y1 = gamma_y[i - 0];
			break;
		}

		x0 = x1;
	}

	return ((x1 - raw8) * y0 + (raw8 - x0) * y1) / (x1 - x0);
}

/* Generated by gengamma.py */
static const uint8_t mpix_gamma_y[] = {
	181, 197, 215, 234,			/* y for gamma = 1 / 16 */
	128, 152, 181, 215,			/* y for gamma = 2 / 16 */
	90, 117, 152, 197,			/* y for gamma = 3 / 16 */
	64, 90, 128, 181,			/* y for gamma = 4 / 16 */
	45, 69, 107, 165,			/* y for gamma = 5 / 16 */
	32, 53, 90, 152,			/* y for gamma = 6 / 16 */
	22, 41, 76, 139,			/* y for gamma = 7 / 16 */
	16, 32, 64, 128,			/* y for gamma = 8 / 16 */
	11, 24, 53, 117,			/* y for gamma = 9 / 16 */
	8, 19, 45, 107,				/* y for gamma = 10 / 16 */
	5, 14, 38, 98,				/* y for gamma = 11 / 16 */
	4, 11, 32, 90,				/* y for gamma = 12 / 16 */
	2, 8, 26, 82,				/* y for gamma = 13 / 16 */
	2, 6, 22, 76,				/* y for gamma = 14 / 16 */
	1, 5, 19, 69,				/* y for gamma = 15 / 16 */
};
static const uint8_t mpix_gamma_x[] = {
	1, 4, 16, 64,				/* x scale */
};

void mpix_correct_gamma_raw8(const uint8_t *src, uint8_t *dst, uint16_t width, uint16_t gamma_q10)
{
	int8_t gamma_q4 = gamma_q10 >> 6;
	const uint8_t *gamma_y = &mpix_gamma_y[(gamma_q4 - 1) * MPIX_GAMMA_STEPS];
	size_t w = 0;

	/* Run as many cycles of SIMD-accelerated code as possible */
#ifdef CONFIG_MPIX_SIMD_NEON
	w += mpix_correct_gamma_raw8_neon(src, dst, width, gamma_q10);
#endif
#ifdef CONFIG_MPIX_SIMD_HELIUM
	w += mpix_correct_gamma_raw8_helium(src, dst, width, gamma_q10);
#endif
#ifdef CONFIG_MPIX_SIMD_RVV
	w += mpix_correct_gamma_raw8_rvv(src, dst, width, gamma_q10);
#endif

	/* Finish with the buffer with C implementation */
	for (; w < width; w++) {
		dst[w] = mpix_gamma_raw8(src[w], gamma_y, mpix_gamma_x, sizeof(mpix_gamma_x));
	}
}

void mpix_correct_gamma_rgb24(const uint8_t *src, uint8_t *dst, uint16_t width, uint16_t gamma_q10)
{
	mpix_correct_gamma_raw8(src, dst, width * 3, gamma_q10);
}

int mpix_run_correct_gamma(struct mpix_base_op *base)
{
	struct mpix_operation *op = (void *)base;
	const uint8_t *src;
	uint8_t *dst;

	MPIX_OP_INPUT_LINES(base, &src, 1);
	MPIX_OP_OUTPUT_LINE(base, &dst);

	switch (base->fmt.fourcc) {
	case MPIX_FMT_SBGGR8:
	case MPIX_FMT_SRGGB8:
	case MPIX_FMT_SGRBG8:
	case MPIX_FMT_SGBRG8:
	case MPIX_FMT_GREY:
		mpix_correct_gamma_raw8(src, dst, base->fmt.width, op->gamma_level_q10);
		break;
	case MPIX_FMT_RGB24:
		mpix_correct_gamma_raw8(src, dst, base->fmt.width * 3, op->gamma_level_q10);
		break;
	default:
		return -ENOTSUP;
	}

	MPIX_OP_OUTPUT_DONE(base);
	MPIX_OP_INPUT_DONE(base, 1);

	return 0;
}
